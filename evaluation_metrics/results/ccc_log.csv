Language,Algorithm,Construct,Line
cirq,01-deutsch-jozsa,for,qubits = [cirq.LineQubit(i) for i in range(n)]
cirq,01-deutsch-jozsa,for,circuit.append(cirq.H(q) for q in qubits + [aux_qubit])
cirq,01-deutsch-jozsa,for,circuit.append(cirq.H(q) for q in qubits)
cirq,01-deutsch-jozsa,for,qubits = [cirq.LineQubit(i) for i in range(n)]
cirq,01-deutsch-jozsa,for,for q in qubits:
cirq,02-bernstein-vazirani,for,qubits = [cirq.LineQubit(i) for i in range(n + 1)]
cirq,02-bernstein-vazirani,for,"for i, bit in enumerate(reversed(s)):"
cirq,02-bernstein-vazirani,if,"if bit == ""1"":"
cirq,03-simon,for,qubits = [cirq.LineQubit(i) for i in range(2 * n)]
cirq,03-simon,for,"for i, bit in enumerate(reversed(s)):"
cirq,03-simon,if,if bit == '1':
cirq,04-grover,for,"for i, bit in enumerate(marked_state):"
cirq,04-grover,if,if bit == '0':
cirq,04-grover,for,"for i, bit in enumerate(marked_state):"
cirq,04-grover,if,if bit == '0':
cirq,04-grover,for,for _ in range(iterations):
cirq,06-qft,for,qubits = [cirq.LineQubit(i) for i in range(n)]
cirq,06-qft,for,for i in range(n):
cirq,06-qft,for,"for j in range(i+1, n):"
cirq,06-qft,for,for i in range(n//2):
quapl,01-deutsch-jozsa,:,:Namespace DJ
quapl,01-deutsch-jozsa,:,(⍴a)=0: ret
quapl,01-deutsch-jozsa,:,:EndNamespace
quapl,01-deutsch-jozsa,:,⍺ {⍵:(((0 ⍺) (⊂SWAP)) stage mid_state) ⋄ mid_state} (⍺≠0)
quapl,02-bernstein-vazirani,:,(⍴⍺)=0: ⍵
quapl,03-simon,:,:Namespace SIMON
quapl,03-simon,:,(⍴⍺)=0: ⍵
quapl,03-simon,:,:EndNamespace
quapl,04-grover,:,:Namespace GROVER
quapl,04-grover,:,((qubits_index) ({⍵=0:#.quapl.gates.X ⋄ ⍵=1:#.quapl.gates.I }¨ x )) #.quapl.circuit.stage vs
quapl,04-grover,:,(⍴(1↓⍺))=0: res
quapl,04-grover,:,:EndNamespace
quapl,04-grover,:,0 = 3⊃⍵: 1⊃⍵
quapl,06-qft,:,(0=⍴1⌷↑swap_circuit):intermediate
quapl,06-qft,:,'Quantum Fourier Transform of basis state |j> is (2*(-n_qubits÷2))×*(0J1)×⍵×j'⊢ (⊃∪#.quapl._r_¨¨∊correct_result-result) Assert 0:
qiskit,01-deutsch-jozsa,for,for i in range(n):
qiskit,02-bernstein-vazirani,for,"for i, bit in enumerate(reversed(s)):"
qiskit,02-bernstein-vazirani,if,"if bit == ""1"":"
qiskit,03-simon,for,"for i, bit in enumerate(reversed(s)):"
qiskit,03-simon,if,if bit == '1':
qiskit,04-grover,for,"for i, bit in enumerate(reversed(marked_state)):"
qiskit,04-grover,if,if bit == '0':
qiskit,04-grover,for,"for i, bit in enumerate(reversed(marked_state)):"
qiskit,04-grover,if,if bit == '0':
qiskit,04-grover,for,for _ in range(iterations):
qiskit,05-vqsvd,and,Qiskit-based Variational Quantum SVD using ADAM and parameter-shift.
qiskit,05-vqsvd,for,for d in range(self.depth):
qiskit,05-vqsvd,for,for q in range(self.num_qubits):
qiskit,05-vqsvd,for,for q in range(self.num_qubits - 1):
qiskit,05-vqsvd,for,for idx in range(dim):
qiskit,05-vqsvd,for,"for q, bit in enumerate(bstr):"
qiskit,05-vqsvd,if,if bit == '1':
qiskit,05-vqsvd,for,"svals = [np.real(product[i, i]) for i in range(self.rank)]"
qiskit,05-vqsvd,for,delayed(grad_i)(i) for i in range(len(x))
qiskit,05-vqsvd,for,"for t in range(1, self.iterations + 1):"
qiskit,05-vqsvd,if,if t % 10 == 0 or t == 1 or t == self.iterations:
qiskit,05-vqsvd,or,if t % 10 == 0 or t == 1 or t == self.iterations:
qiskit,05-vqsvd,for,"for i in range(1, rank + 1):"
qiskit,05-vqsvd,and,Initializes the plotting utility and creates the output directory.
qiskit,05-vqsvd,and,Plots the loss curve over iterations and saves it.
qiskit,05-vqsvd,for,Compares singular value reconstruction errors for VQSVD and classical SVD.
qiskit,05-vqsvd,and,Compares singular value reconstruction errors for VQSVD and classical SVD.
qiskit,05-vqsvd,and,Displays and saves the matrix as a grayscale image.
qiskit,05-vqsvd,and,"Loads a grayscale image of size 2^n × 2^n and normalizes its pixel values to [0, 1]."
qiskit,05-vqsvd,if,"if __name__ == ""__main__"":"
qiskit,05-vqsvd,while,"print(""Starting training… (this may take a while)"")"
qiskit,06-qft,if,if n == 0:
qiskit,06-qft,for,for qubit in range(n):
qiskit,06-qft,for,for qubit in range(n//2):
qrisp,01-deutsch-jozsa,for,for i in range(len(input_qubits)):
qrisp,02-bernstein-vazirani,for,for i in range(len(s)):
qrisp,02-bernstein-vazirani,if,"if s[i] == ""1"":"
qrisp,03-simon,for,for i in range(len(s)):
qrisp,03-simon,if,"if s[i] == ""1"":"
qrisp,06-qft,for,for i in range(n):
qrisp,06-qft,for,"for j in range(i+1, n):"
qrisp,06-qft,for,for i in range(n//2):
qmod,02-bernstein-vazirani,repeat,repeat (i: x.len) {
qmod,02-bernstein-vazirani,if,if ((floor(a / (2 ** i)) % 2) == 1) {
q#,01-deutsch-jozsa,for,for i in 0..n-1 {
q#,02-bernstein-vazirani,for,for i in 0..n - 1 {
q#,02-bernstein-vazirani,if,if (s[n - 1 - i]) {
q#,03-simon,for,for i in 0..n - 1 {
q#,03-simon,if,if (s[n - 1 - i]) {
q#,04-grover,for,for i in 0..n - 1 {
q#,04-grover,if,if (not markedState[n - 1 - i]) {
q#,04-grover,for,for i in 0..n - 1 {
q#,04-grover,if,if (not markedState[n - 1 - i]) {
q#,04-grover,for,for _ in 1..iterations {
q#,06-qft,for,for i in 0 .. nQubits - 1 {
q#,06-qft,for,for j in i+1 .. nQubits - 1 {
q#,06-qft,for,for i in 0 .. (nQubits / 2 - 1) {
qasm3,01-deutsch-jozsa,for,for int i in [0:3] {
qasm3,01-deutsch-jozsa,for,for int i in [0:2] {
qasm3,01-deutsch-jozsa,for,for int i in [0:2] {
qasm3,02-bernstein-vazirani,for,for int i in [0:3] {
qasm3,02-bernstein-vazirani,for,for int i in [0:3] {
qasm3,03-simon,for,for int i in [0:2] {
qasm3,03-simon,for,for int i in [0:2] {
qasm3,04-grover,for,for int i in [0:2] {
qasm3,04-grover,for,for int i in [0:2] {
qasm3,04-grover,for,for int i in [0:2] {
qasm3,04-grover,for,for int i in [0:2] {
qasm3,04-grover,for,for int i in [0:2] {
pennylane,01-deutsch-jozsa,for,for i in range(n):
pennylane,01-deutsch-jozsa,for,for i in range(n):
pennylane,01-deutsch-jozsa,for,for i in range(n):
pennylane,02-bernstein-vazirani,for,for i in range(n):
pennylane,02-bernstein-vazirani,for,"for i, bit in enumerate(reversed(s)):"
pennylane,02-bernstein-vazirani,if,"if bit == ""1"":"
pennylane,03-simon,for,for i in range(n):
pennylane,03-simon,for,"for i, bit in enumerate(reversed(s)):"
pennylane,03-simon,if,if bit == '1':
pennylane,04-grover,for,for i in n:
pennylane,04-grover,for,for i in n:
pennylane,04-grover,for,"for i, bit in enumerate(marked_state):"
pennylane,04-grover,if,if bit == '0':
pennylane,04-grover,for,for _ in range(iterations):
pennylane,05-vqsvd,for,for d in range(depth):
pennylane,05-vqsvd,for,for q in range(num_qubits):
pennylane,05-vqsvd,for,for q in range(num_qubits - 1):
pennylane,05-vqsvd,for,"basis_states = [format(i, f""0{num_qubits}b"") for i in range(2**num_qubits)]"
pennylane,05-vqsvd,for,"for j, bit in enumerate(reversed(state_bin)):"
pennylane,05-vqsvd,if,"if bit == ""1"":"
pennylane,05-vqsvd,for,for b in basis_states:
pennylane,05-vqsvd,for,for i in range(self.rank):
pennylane,05-vqsvd,for,for itr in range(self.itr):
pennylane,05-vqsvd,if,if itr % 10 == 0:
pennylane,05-vqsvd,for,for i in range(RANK):
pennylane,06-qft,for,for i in range(n):
pennylane,06-qft,for,"for j in range(i + 1, n):"
pennylane,06-qft,for,for i in range(n // 2):
paddle,05-vqsvd,for,for _ in range(depth):
paddle,05-vqsvd,for,for i in range(self.rank):
paddle,05-vqsvd,for,for itr in range(self.itr):
paddle,05-vqsvd,if,if itr% 10 == 0:
paddle,05-vqsvd,for,for i in range(RANK):
paddle,05-vqsvd,for,"for i in range(5, 16, 5):"
paddle,05-vqsvd,for,for _ in range(depth):
